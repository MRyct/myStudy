#### 一、请说出下列最终的执行结果，并解释为什么？
```javascript
var a = []
for(var i = 0;  i < 10; i++) {
    a[i] = function() {
       // i = i
        console.log(i)
    }
}
a[6]()
```

**结果** `10`

**原因** 因为在js中`var`关键字声明变量会有变量提升的特点（也就是说-《以上例子》`var`会把`i`提到函数作用域的顶端—当前指`全局`，在for循环 的每一次循环 a[i]就对`function`有一次引用，然后在其函数内部`i`也是一次`i`对`i`的引用，也就是函数内部`i`对全局`i`的引用，当循环结束时`i = 10`的，因此a数组中无论那一项的`function` 调用之后得到的都是`10`

**解决** 想要解决这种情况的话, 首先要想办法让每一次循环`i`的值只属于当前a[i] - 闭包

#### 二、下列代码执行结果，解释原因

```javascript
var temp = 123
if(true) {
  console.log(temp)
  let temp
}
// VM12755:3 Uncaught ReferenceError: Cannot access 'temp' before initialization
```

**结果** 无法在初始化之前访问“temp”

**原因** let 声明的变量 作用域是if代码块，而且let声明变量不能提升,因此在let 声明前使用变量是错误的。所以会提示在初始化前不能访问该变量。

#### 三、用ES6新语法，用最简单的方式找出数组中最小值

```javascript
var arr = [12, 34, 32,  89, 4]

var getMin = (arr) => Math.min(...arr) 

var arrMin = getMin(arr)
```

#### 四、let、const、var 声明变量的差别

- let 声明的变量在它所在的代码块中有效（块级作用域），且可以修改值
- const 声明的是常量/恒量，不可修改指向的内存地址
- var 声明变量，具有变量提升的特性

#### 五、下列输出的结果及原因

```javascript
var a = 10
var obj = {
  a: 20,
  fun() {
    setTimeout(() => {
      console.log(this.a)
    })
  }
}
abj.fun()
// 20
```

**结果** 20

**原因** <font color=red>this</font>是谁调用指向谁，上列代码中指向`obj`，再有ES6中的<font color=red>箭头函数是作用在上一层作用域链上的</font>,可以说是箭头函数不会改变`this`指向。因此`this.a`的值是`20`

#### 六、Symbol使用场景

> Symbol 是一种数据类型，Symbol 值是唯一的 

- 设置对象的的属性
- 设置类的私有属性
- 注册定义和获取全局Symbol
- 声明独一无二的常量

#### 七、浅拷贝、深拷贝

从表现上看，如果A对象使用浅拷贝出B，修改B的属性A页随之修改，而深拷贝不会

- **浅拷贝**根本上只复制了对象的指针，复制前的对象和复制后的对象都存在于同一个内存空间，虽然复制出了一个新对象 但<font color=red>实际上还是指向同一个内存地址</font>
- **深拷贝**是复制出一个新对象，重新开辟出一个新的内存空间来存放，内存地址变了

#### 八、Typescript 和Javascript的关系

Typescript是javasctipt的超集，也就是说在javascipt的基础增加了一些比较好的特性，javascipt是一门弱类型的语言，而Typescript是一门强类型的语言，可以通过TS来弥补JS的不足，但是TS不能直接在浏览器等环境下执行，它需编译成JS。

#### 九、Typesctipt 优缺点

**优点**:  

- 增加了代码的可读性和可维护性 （对比js来说Ts编码更加规范，更加严格，因此提高代码可读性和可维护性
- 减少运行阶段的Bug率 （类型检查系统在编译阶段就会对代码检查，如果有错误的话会立即报错，就不会等到运行阶段了）
- TypeScript有比较活跃的社区 
  - 现在在很多库里面都会看到.ts相关的文件，兼容TS及JS个语言的版本
  - 像angular2也是采用TS编写的，VUE3也使用TS编写
- IDEA 支持良好 
  - Visual Studio Code 编译器和TS一样同是微软出的，因此本身上具备一定的优势，增强了编译器对TS的支持，具备代码提示、接口提示、跳转定义、重构等功能。
- TypeScript 拥抱ES6规范，而且TS是一门渐进式的语言，对于熟悉JS的开发者来说其实很容易上手开发的。

**缺点**:

- 对于短期项目会增加一些开发成本
- 有一定的学习成本 （因为对于部分JS开发者来说 TS一些特性还是有点陌生的）
- 有一部分的库对TS支持不是太好甚至不支持

#### 十、引用计数算法的工作原理及优缺点

**原理** 引用计数算法就是每增加一个引用，引用计数+1，去掉一个引用，引用计数-1，当引用计数为0时，改对象被视为垃圾，被GC

**缺点** 当C对A有引用，B对C有引用，A对B有引用，这时他们就形成了`循环引用`，他们的引用计数永远都不会为0，形成不了垃圾，也就触发不了GC。

#### 十一、标记整理算法的工作流程

标记整理算法分为`标记`和`整理`两个阶段

**标记阶段**:  标记可达对象，移动、排序

**清楚阶段**：清楚所有不可达对象 （未存活）

>从根出发，遍历所有对象，将所有的可达对象标记为`存活对象`，将所有的`存活对象`按照顺序重新整理排列在内存中,修改地址，将末端以外的内存都回收，（可以理解为，所有的存活对象，以此移动到一端，将存活对象末尾的所有对象都清楚掉）

#### 十二、V8中新生代存储区垃圾回收的流程

V8采用分代回收垃圾回收的策略，将内存分为新生代和老生代区域，短期存活的对象放在新生代区域，存活周期较长的放在老生代区域（全局变量等）

**新生代**：新生代区域又分为from（使用状态）、to(空闲状态)两个区域, 具体的流程是：

- 1、新声明的对象分配from区

- 2、将from中所有从根出发可达的对象复制到to区域，不可达对象视为垃圾 进行清除。然后from和to进行交换，原from—>现to,原to—>现from（循环执行相同的操作）
- 3、晋升 （新生代晋升到老生代)
  - 如果一轮循环完成之后 还存活的对象 将会复制到老生代区域
  - 如果这个对象所占内存超过25%,不会被复制到to中，它会直接晋升到老生代中

#### 十三、增量标记算法在何时工作以及工作原理

在老生代进行垃圾回收时工作

**原理**: 由于js脚本是运行咋渲染进程的主线程上，V8在进行垃圾回收时，js脚本会停止运行，程序会出现卡顿现象，等待垃圾回收完成才会恢复。为了减少停顿，V8将标记过程分为若干子标记过程，与js脚本交替执行，知道标记阶段结束。