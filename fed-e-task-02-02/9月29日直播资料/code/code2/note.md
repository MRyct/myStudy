### bunle.js 
- 我们模块中的代码经过 webpack 打包之后，就被放在了一个自执行函数中
- 这个自调用函数接收一个参数，它的值是一个对象，这个对象的键就是相对于当前项目来说，
  被打包文件的路径(moduleId)，它的值就是我们被打包模块中的源代码，这个函数定义的
  时候接收了二个参数 module exports 
- 我们在写代码的时候会使用 ESmodule 或者 commonjs 规范的 module，而 webpack 都可以处理
- 因为它的内部自己实现了很多自定义方法（）

### bundle.js 流程
以单模块打包，且这个模块中没有其它的导包操作为例
01 将所有的内容都放置于一个自调用函数中，然后将被打包模块相关信息进行传参
02 相关信息就是一个对象，格式就是 moduleId:组装后的函数( 函数体就是打包前的源码 )
03 自调用函数体内定义一个空对象用于存储缓存
03 自定义一个 __webpack_require__ 函数，它接收一个 ModuleId
04 这个 moduleId 是在自调用函数体的最后一行调用时传入的，100%就是入口文件的ID
05 自调用函数逻辑：
  - 判断当前 ModuleID 对应的模块是否存在于缓存中
  - 如果缓存中不存在的情况下，就自定义的一个 module 存放一个对象
  - 同时还将这个 对象存放在了 installModules[moduleId] 里
  - 这个对象有三个属性： i , l , exports={}
  - 通过 Modules[moduleId] 找到最初组装的那个函数以 call 的方式来调用
  - 首先修改了this指向，然后传入了 module 和 module.exports , 最后还有
  一个 __webpack_require__ ，为了将来应对被打包模块中还有其它的模块导入
  - 余下的就是一些......

### 常见工具方法的作用
- o: 可以判断当前对象中是否存在某个指定的属性 
- d: 给对象的某个属性添加一个 getter 
- r: 将对象标记为 __esModule 
- t: 太恶了放在最后看 
- n: 依据不同的模块返回一个返回模块内容的 getter
